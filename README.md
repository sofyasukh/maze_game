# Архитектура проекта "Лабиринт"

## Обзор

Проект построен с использованием архитектурного паттерна **Model-View-Controller (MVC)**, который разделяет логику обработки данных, пользовательский интерфейс и управляющую логику на три взаимосвязанных компонента.

- **Model**: Отвечает за данные и бизнес-логику игры.
- **View**: Отвечает за отображение данных (пользовательский интерфейс).
- **Controller**: Обрабатывает ввод пользователя и взаимодействует с Model и View.

## Структура проекта

```
maze_game/
├── models/          # (Model) Логика и состояние игры
│   ├── maze.py      # Генерация и логика лабиринта
│   ├── player.py    # Логика игрока
│   ├── bonus.py     # Логика бонусов
│   └── game_state.py # Основное состояние игры
│
├── views/           # (View) Все, что связано с отрисовкой
│   ├── game_view.py # Отрисовка игрового процесса
│   └── menu_view.py # Отрисовка меню
│
├── controllers/     # (Controller) Управляющая логика
│   ├── game_controller.py  # Управление игровым процессом
│   ├── menu_controller.py  # Управление меню
│   └── sound_controller.py # Управление звуками
│
├── assets/          # Все игровые ресурсы
│   ├── images/      # Изображения
│   └── sounds/      # Звуки
│
├── utils/
│   └── asset_manager.py # Менеджер для загрузки ресурсов
│
├── config.py        # Глобальные константы и настройки
└── run_game.py      # Главный игровой цикл и точка входа
```

## Взаимодействие компонентов

1.  **`run_game.py`**: Инициализирует Pygame, создает главный `AssetManager` и запускает `MenuController`.
2.  **`MenuController`**: Управляет навигацией по меню. Получает ввод от пользователя и передает команды `MenuView` для отрисовки и `SoundController` для звуков. При выборе уровня запускает `GameController`.
3.  **`GameController`**: Управляет игровым циклом.
    -   Получает ввод от пользователя (движение, пауза).
    -   Обновляет `GameState` (модель).
    -   Вызывает `GameView` для отрисовки `GameState`.
    -   Вызывает `SoundController` для воспроизведения звуковых эффектов на основе событий в `GameState`.
4.  **`GameState` (Модель)**: Содержит всю игровую логику (положение игрока, состояние лабиринта, бонусы). Ничего не знает о View и Controller. Сообщает контроллеру об изменениях через флаги (например, `last_applied_bonus`).
5.  **`GameView` (Представление)**: Получает `GameState` и отрисовывает его. Не содержит никакой игровой логики.
6.  **`AssetManager`**: Загружает все ресурсы в начале игры и предоставляет к ним доступ по ключу, предотвращая дублирование загрузки.

Такое разделение делает код более модульным, тестируемым и легким для понимания и расширения.
